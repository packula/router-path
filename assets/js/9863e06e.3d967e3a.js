"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[119],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>c});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),l=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(i.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),h=l(a),c=r,g=h["".concat(i,".").concat(c)]||h[c]||m[c]||s;return a?n.createElement(g,o(o({ref:t},u),{},{components:a})):n.createElement(g,o({ref:t},u))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=h;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var l=2;l<s;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(6010);const s="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,o),hidden:a},t)}},5488:(e,t,a)=>{a.d(t,{Z:()=>c});var n=a(7462),r=a(7294),s=a(6010),o=a(2389),p=a(7392),i=a(7094),l=a(2466);const u="tabList__CuJ",m="tabItem_LNqP";function h(e){var t,a;const{lazy:o,block:h,defaultValue:c,values:g,groupId:d,className:y}=e,f=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=g?g:f.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),b=(0,p.l)(k,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const w=null===c?c:null!=(t=null!=c?c:null==(a=f.find((e=>e.props.default)))?void 0:a.props.value)?t:f[0].props.value;if(null!==w&&!k.some((e=>e.value===w)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+k.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:N,setTabGroupChoices:v}=(0,i.U)(),[A,C]=(0,r.useState)(w),x=[],{blockElementScrollPositionUntilNextRender:T}=(0,l.o5)();if(null!=d){const e=N[d];null!=e&&e!==A&&k.some((t=>t.value===e))&&C(e)}const S=e=>{const t=e.currentTarget,a=x.indexOf(t),n=k[a].value;n!==A&&(T(t),C(n),null!=d&&v(d,String(n)))},I=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{var n;const t=x.indexOf(e.currentTarget)+1;a=null!=(n=x[t])?n:x[0];break}case"ArrowLeft":{var r;const t=x.indexOf(e.currentTarget)-1;a=null!=(r=x[t])?r:x[x.length-1];break}}null==(t=a)||t.focus()};return r.createElement("div",{className:(0,s.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":h},y)},k.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:A===t?0:-1,"aria-selected":A===t,key:t,ref:e=>x.push(e),onKeyDown:I,onFocus:S,onClick:S},o,{className:(0,s.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":A===t})}),null!=a?a:t)}))),o?(0,r.cloneElement)(f.filter((e=>e.props.value===A))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==A})))))}function c(e){const t=(0,o.Z)();return r.createElement(h,(0,n.Z)({key:String(t)},e))}},3358:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>l});var n=a(7462),r=(a(7294),a(3905));a(5162),a(5488);const s={id:"path-patterns",title:"Path patterns",sidebar_label:"Path patterns"},o=void 0,p={unversionedId:"guides/path-patterns",id:"guides/path-patterns",title:"Path patterns",description:"A path pattern is a way to express the structure that a path must take in",source:"@site/../docs/guides/path-patterns.mdx",sourceDirName:"guides",slug:"/guides/path-patterns",permalink:"/router-path/guides/path-patterns",draft:!1,editUrl:"https://github.com/snout-router/router-path/edit/main/website/../docs/guides/path-patterns.mdx",tags:[],version:"current",frontMatter:{id:"path-patterns",title:"Path patterns",sidebar_label:"Path patterns"},sidebar:"docs",previous:{title:"Getting started",permalink:"/router-path/guides/getting-started"},next:{title:"Custom parameters",permalink:"/router-path/guides/custom-parameters"}},i={},l=[{value:"Creating patterns",id:"creating-patterns",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Parameter affixes",id:"parameter-affixes",level:3},{value:"Patterns with multiple parameters",id:"patterns-with-multiple-parameters",level:3},{value:"Patterns with no parameters",id:"patterns-with-no-parameters",level:3},{value:"Matching paths",id:"matching-paths",level:2},{value:"Matches with multiple parameters",id:"matches-with-multiple-parameters",level:3},{value:"Matches with no parameters",id:"matches-with-no-parameters",level:3},{value:"Match types",id:"match-types",level:3},{value:"Simple parameter matching",id:"simple-parameter-matching",level:3},{value:"Custom parameter matching",id:"custom-parameter-matching",level:3},{value:"URL path matching",id:"url-path-matching",level:3},{value:"Building paths",id:"building-paths",level:2},{value:"Why build paths?",id:"why-build-paths",level:3},{value:"Building with multiple parameters",id:"building-with-multiple-parameters",level:3},{value:"Building with no parameters",id:"building-with-no-parameters",level:3},{value:"Build argument types",id:"build-argument-types",level:3},{value:"Building with simple parameters",id:"building-with-simple-parameters",level:3},{value:"Building with custom parameters",id:"building-with-custom-parameters",level:3},{value:"Building URL paths",id:"building-url-paths",level:3}],u={toc:l};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"path pattern")," is a way to express the structure that a ",(0,r.kt)("em",{parentName:"p"},"path")," must take in\norder to identify a particular resource, endpoint, or portion of your\napplication. Path patterns are what ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," is all about!"),(0,r.kt)("p",null,"In this guide, we'll cover:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"How to create your own path patterns using the ",(0,r.kt)("a",{parentName:"li",href:"/router-path/api/path"},(0,r.kt)("inlineCode",{parentName:"a"},"path"))," function"),(0,r.kt)("li",{parentName:"ul"},"Utilizing parameters in your patterns to implement dynamic path segments"),(0,r.kt)("li",{parentName:"ul"},"Determining whether a path matches your pattern"),(0,r.kt)("li",{parentName:"ul"},"Turning a path that matches your pattern into a set of arguments that your\napplication understands"),(0,r.kt)("li",{parentName:"ul"},"How to take a set of arguments, and turn them back into a path that matches\nyour pattern")),(0,r.kt)("h2",{id:"creating-patterns"},"Creating patterns"),(0,r.kt)("p",null,"To create a path pattern, call the ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/path"},(0,r.kt)("inlineCode",{parentName:"a"},"path"))," function by using it in a\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"},"tagged template literal"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\n// This pattern would suit paths like /user/111 or /user/some-string-id\nconst user = path`/user/${"id"}`;\n')),(0,r.kt)("p",null,"The definition of the path pattern is enclosed in backtick characters (",(0,r.kt)("inlineCode",{parentName:"p"},"`"),").\nAny ",(0,r.kt)("em",{parentName:"p"},"substitutions")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"${'id'}"),") become the path pattern's parameters. The\nsurrounding text segments are interpreted literally, and become the static parts\nof the path pattern. These text segments can be used on either side of a\nsubstitution, effectively forming static prefixes and suffixes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'// This pattern would suit paths like /group/snout/members or /group/P19/members\nconst groupMembers = path`/group/${"slug"}/members`;\n')),(0,r.kt)("p",null,"In the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"groupMembers")," example pattern:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"/group/")," text segment becomes a static prefix"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"${'slug'}")," substitution becomes a parameter named 'slug'"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"/members")," text segment becomes a static suffix")),(0,r.kt)("admonition",{title:"Why tagged templates?",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you're not used to the ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"},"tagged template literal")," syntax, don't worry. Tagged\ntemplates ",(0,r.kt)("em",{parentName:"p"},"are")," a lesser-known JavaScript language feature, but they've been\n",(0,r.kt)("a",{parentName:"p",href:"https://caniuse.com/template-literals"},"supported by all modern browsers")," for some time now. They're really just a\nfancy way to call a function."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," uses tagged template literals because it means there's no\nneed to invent a special syntax for defining path patterns. The ",(0,r.kt)("em",{parentName:"p"},"JavaScript\nlanguage itself")," already does the work of parsing your path pattern into\nparameters and literal text segments.")),(0,r.kt)("h3",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"So far, the parameters we've shown have been created using substitutions with\nstrings. For example, when you define the following ",(0,r.kt)("inlineCode",{parentName:"p"},"imagesByCategory")," example\npattern, you also create a simple parameter named ",(0,r.kt)("inlineCode",{parentName:"p"},"category"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst imagesByCategory = path`/images/${"category"}`;\n')),(0,r.kt)("p",null,"We'll go into more detail about exactly how these simple parameters behave in\nthe sections on ",(0,r.kt)("a",{parentName:"p",href:"#simple-parameter-matching"},"simple parameter matching")," and\n",(0,r.kt)("a",{parentName:"p",href:"#building-with-simple-parameters"},"building with simple parameters"),", but for now all you need to know is that\nusing a string is a short-hand method for creating a simple parameter, with the\nstring becoming the ",(0,r.kt)("em",{parentName:"p"},"name")," of the new parameter."),(0,r.kt)("p",null,"In order to keep ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," light and easy to maintain, only these\nsimple parameters are included out of the box. In most cases, they should be all\nyou need. However, ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," does include a powerful system for\nimplementing ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameters"),". You can implement parameters that utilize\nother data types, other path separators, optional parameters, repeating\nparameters, and just about any kind of parameter you can imagine."),(0,r.kt)("p",null,"There's also a separate ",(0,r.kt)("a",{parentName:"p",href:"https://snout.dev/router-path-extras"},(0,r.kt)("inlineCode",{parentName:"a"},"@snout/router-path-extras"))," package, which has some\ncommonly desired parameter type implementations. When you use ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameter"),"\nimplementations like the ones in this package, you typically need to call a\nseparate function to create the parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { some } from "@snout/router-path-extras";\n\n// This pattern would suit paths like /tagged/snout or /tagged/squishy/pigs\nconst tagged = path`/tagged/${some("tags")}`;\n')),(0,r.kt)("p",null,"In the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"tagged")," example pattern, we're using a custom parameter\nimplementation called ",(0,r.kt)("inlineCode",{parentName:"p"},"some"),", which is based on an array containing one or more\nstrings. Note that instead of a string substitution like ",(0,r.kt)("inlineCode",{parentName:"p"},"${'id'}"),", we're using\na function call - ",(0,r.kt)("inlineCode",{parentName:"p"},"${some('tags')}"),". We're still setting the parameter name with\na string, but this time it's an argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"some")," parameter creator\nfunction."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"There's no strict requirement for parameters to be created inline. For example,\nthis is an alternate way to define the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"tagged")," example pattern:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const tagsParam = some("tags");\nconst tagged = path`/tagged/${tagsParam}`;\n'))),(0,r.kt)("h3",{id:"parameter-affixes"},"Parameter affixes"),(0,r.kt)("p",null,"It's quite common for a parameter to take up an entire segment of a path\npattern. That is, in the following ",(0,r.kt)("inlineCode",{parentName:"p"},"groupMembers")," example pattern, the ",(0,r.kt)("inlineCode",{parentName:"p"},"slug"),"\nparameter takes up the entire middle segment of the pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst groupMembers = path`/group/${"slug"}/members`;\n')),(0,r.kt)("p",null,"But there's nothing to say that a parameter must begin and end with ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),"\ncharacters like this. You can also add static prefixes or suffixes around a\nparameter by adding them to the text portion of a pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const servicesWithLabel = path`/services/with-${"label"}-label`;\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Parameter affixes can also be implemented in custom parameters. See the\n",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters#parameter-affixes"},"custom parameters guide section on parameter affixes")," to see how.")),(0,r.kt)("h3",{id:"patterns-with-multiple-parameters"},"Patterns with multiple parameters"),(0,r.kt)("p",null,"You can create path patterns with multiple parameters by using multiple\nsubstitutions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\n// This pattern would suit paths like /v1/guides/getting-started or /latest/guides/installation\nconst guide = path`/${"version"}/guides/${"name"}`;\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"When you specify multiple parameters in a path pattern, you should make sure\nthat parameters don't share names. This could result in undefined behavior.")),(0,r.kt)("h3",{id:"patterns-with-no-parameters"},"Patterns with no parameters"),(0,r.kt)("p",null,"You can create a path patterns with no parameters by using no substitutions. But\nyou still need to call the ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/path"},(0,r.kt)("inlineCode",{parentName:"a"},"path"))," function using ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"},"tagged template literal"),"\nsyntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\n// This pattern would suit the path /pages/faq only\nconst faq = path`/pages/faq`;\n')),(0,r.kt)("h2",{id:"matching-paths"},"Matching paths"),(0,r.kt)("p",null,"You can check if a path matches your path pattern by using the ",(0,r.kt)("a",{parentName:"p",href:"../api/type/PathPattern#method-match"},(0,r.kt)("inlineCode",{parentName:"a"},"match"))," method.\nIf the path matches, then ",(0,r.kt)("a",{parentName:"p",href:"../api/type/PathPattern#method-match"},(0,r.kt)("inlineCode",{parentName:"a"},"match"))," will parse the path into a set of arguments.\nIf it does not match, then ",(0,r.kt)("a",{parentName:"p",href:"../api/type/PathPattern#method-match"},(0,r.kt)("inlineCode",{parentName:"a"},"match"))," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst user = path`/user/${"id"}`;\n\nuser.match("/user/111"); // returns {id: \'111\'}\nuser.match("/user/snoutabout"); // returns {id: \'snoutabout\'}\n\n// returns undefined - this path does not match the pattern\nuser.match("/settings/notifications");\n')),(0,r.kt)("p",null,"If you only want to know whether a pattern matches a path, but you don't need\nthe parsed arguments, you can use the simpler ",(0,r.kt)("a",{parentName:"p",href:"../api/type/PathPattern#method-test"},(0,r.kt)("inlineCode",{parentName:"a"},"test"))," method, which returns a\nboolean indicating whether the path matched instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'user.test("/user/111"); // returns true\nuser.test("/user/snoutabout"); // returns true\nuser.test("/settings/notifications"); // returns false\n')),(0,r.kt)("p",null,'Paths are only considered to be "matching" when the pattern matches the ',(0,r.kt)("em",{parentName:"p"},"whole"),"\npath. For example, if you create a path with no parameters, you will notice that\npartial matches cannot occur:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const recentArticles = path`/articles/recent`;\n\n// returns false - this path does not match, due to the extra prefix\nrecentArticles.test("/feed/articles/recent");\n\n// returns false - this path does not match, due to the extra suffix\nrecentArticles.test("/articles/recent/tagged/snout");\n')),(0,r.kt)("h3",{id:"matches-with-multiple-parameters"},"Matches with multiple parameters"),(0,r.kt)("p",null,"If your path pattern has multiple parameters, a successful match will produce\narguments that have a property for each parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst pluginSettings = path`/plugin/${"plugin"}/settings/${"type"}`;\n\n// returns {plugin: \'snout-router\', type: \'routes\'}\npluginSettings.match("/plugin/snout-router/settings/routes");\n\n// returns {plugin: \'dogma\', type: \'apps\'}\npluginSettings.match("/plugin/dogma/settings/apps");\n')),(0,r.kt)("h3",{id:"matches-with-no-parameters"},"Matches with no parameters"),(0,r.kt)("p",null,"If your path pattern has no parameters, a successful match will produce empty\narguments (i.e. an empty object):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst dashboard = path`/dashboard`;\n\ndashboard.match("/dashboard"); // returns {}\n')),(0,r.kt)("h3",{id:"match-types"},"Match types"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),", you'll get bonus type safety with your matches.\nOnce you've checked that a path does in fact match your pattern, the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," compiler will warn you if you're using a nonexistent argument, and\nwill also know the types of your arguments, preventing you from using them\nincorrectly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { some } from "@snout/router-path-extras";\n\nconst articles = path`/articles/${"category"}/tagged/${some("tags")}`;\n\n// TypeScript "knows" that successful match arguments will contain:\n//   - category: A string\n//   - tags:     An array of strings with at least one member\nconst match = articles.match("/articles/pachyderms/tagged/huge/snouts");\n\nif (match) {\n  console.log(match.category); // no error\n  console.log(match.tags); // no error\n  console.log(match.tags[0].toLowerCase()); // no error\n  console.log(match.tags[1].toLowerCase()); // type error (if noUncheckedIndexedAccess is enabled)\n  console.log(match.nonexistent); // type error\n}\n')),(0,r.kt)("admonition",{title:"Try me!",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?noUncheckedIndexedAccess=true#code/JYWwDg9gTgLgBAbzAQxgCwL5wGZQiOAcgAEBnAOwgFcYB6PGgUygFoV1CAoUSWRU-Iyy58RMpRr1qMZm1RoWjAB4woyUl04BjCOVLxksYFoA2jUnAC8cdmgAGtQzGNnStACQJCW1IwDm0ACehBi0MMh+fowAJh4IAiCMABSE4X4aAJQYdpyctLRwACqBYIwAylpQwGDwAEQA1pQA7qS1cOiocKRUWlrmpNhUJnAgqFpocIZ+VInkMBZNwCbDOnPIwOQAXHkFcHAscD4yAVCBm3AAgl2qG347e-vtEaTnD5fkk1BqgXAQ2NdVcjpOCLdCTeBmdTwXSMEaMEAAI2Y2l0+hGYwm1icLnMADpRjBxilHEZTOZaChxoFoswQG40lFYmgqFFaBRpJlcsB-kkCeMMohOHtVgIzLiTBA-LyMbijv4ggK3kq3vk4JQ4Mw8FAhYdURAxRKpXy0Li0qRFcrLQ9VerNdAdSL9YxxZLpYSTWaANoABgAuqaIAAZCBNZgAYXUyQyAptEA1X3twr1BtdxtNz09AEZ-TAgyHw5GktG4KqYCVYXaoHAkty1RAAKrkcaMLT1GIASXINKUMQuvX6cGAFkY5GQCLM0QyDuTzsNbvGuMo5GUQ5kcwtVtL5fjWs4GCAA"},"Try this example in the TypeScript Playground"))),(0,r.kt)("h3",{id:"simple-parameter-matching"},"Simple parameter matching"),(0,r.kt)("p",null,"The simple parameters that come out of the box with ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," are\ndesigned to work with paths where the segments are separated with ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),"\ncharacters. They will consume anything up until the first ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," character, or the\nend of the path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst user = path`/user/${"id"}`;\n\n// returns {id: \'\ud83d\udc49 \ud83d\udc3d \ud83d\udc48\'}\nuser.match("/user/\ud83d\udc49 \ud83d\udc3d \ud83d\udc48");\n\n// returns {id: \':?#%\'} - there are no special characters other than /\nuser.match("/user/:?#%");\n\n// returns undefined - the id parameter will only consume one segment\nuser.match("/user/111/profile");\n')),(0,r.kt)("p",null,"Simple parameters will ",(0,r.kt)("strong",{parentName:"p"},"not")," match empty path segments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const groupMembers = path`/group/${"slug"}/members`;\n\n// returns undefined - the slug argument is empty\ngroupMembers.match("/group//members");\n\nconst user = path`/user/${"id"}`;\n\n// returns undefined - the id argument is empty\nuser.match("/user/");\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," as a path separator is definitely the most common use case, but\n",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," can be used with other separators. See the\n",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters#path-separators"},"custom parameters guide section on path separators")," to see how.")),(0,r.kt)("p",null,'The arguments produced by simple parameters will always be strings. There is\ndeliberately no "magic" type coercion going on:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const group = path`/group/${"id"}`;\n\n// returns {id: \'111\'} - note that id is a string, not a number\ngroup.match("/group/111");\n')),(0,r.kt)("p",null,"If you want parameters that produce other types of arguments, then you'll need\nto look into ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameters"),"."),(0,r.kt)("h3",{id:"custom-parameter-matching"},"Custom parameter matching"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameters")," in your patterns, the type and content of\nthe arguments you'll get for successful matches is largely up to the\nimplementation of each parameter. Some ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameter")," implementations just\nproduce argument types other than strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { int } from "@snout/router-path-extras";\n\nconst job = path`/job/${int("num")}`;\n\n// returns {num: 111} - note that num is a number, not a string\njob.match("/job/111");\n')),(0,r.kt)("p",null,"But ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameter")," implementations also have the power to transform the\narguments in just about any way. So check their individual documentation for\nmore specific information on how they behave when matching paths:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { optional } from "@snout/router-path-extras";\n\nconst pachyderms = path`/pachyderms${optional`/with/${"feature"}`}`;\n\n// returns {feature: undefined}\npachyderms.match("/pachyderms");\n\n// returns {feature: \'snouts\'}\npachyderms.match("/pachyderms/with/snouts");\n')),(0,r.kt)("h3",{id:"url-path-matching"},"URL path matching"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," does not automatically decode URL paths. If you're using\nyour path pattern to match against URL paths, make sure you decode the path\nwith ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent"},(0,r.kt)("inlineCode",{parentName:"a"},"decodeURIComponent"))," before matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst article = path`/article/${"name"}`;\nconst url = new URL("https://snout.dev/article/10%20Biggest%20Snouts");\n\n// returns {name: \'10 Biggest Snouts\'}\narticle.match(decodeURIComponent(url.pathname));\n')),(0,r.kt)("h2",{id:"building-paths"},"Building paths"),(0,r.kt)("p",null,"You can create a path from your pattern by using the ",(0,r.kt)("a",{parentName:"p",href:"../api/type/PathPattern#method-build"},(0,r.kt)("inlineCode",{parentName:"a"},"build"))," method. You'll\nneed to supply appropriate arguments to build with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst user = path`/user/${"id"}`;\n\nuser.build({ id: "111" }); // returns \'/user/111\'\nuser.build({ id: "snoutabout" }); // returns \'/user/snoutabout\'\n')),(0,r.kt)("p",null,"It's safe to supply additional arguments. If you do, they will have no affect on\nthe output path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'user.build({ username: "pachyderm", id: "222" }); // returns \'/user/222\'\n')),(0,r.kt)("h3",{id:"why-build-paths"},"Why build paths?"),(0,r.kt)("p",null,"By building your paths instead of writing them by hand, you can reduce the\nlikelihood of human error in your application. For example, say you were\nbuilding a social application where users get their own profile page. You decide\nto give everyone a route matching their username at the root of your\napplication:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const profile = path`/${"username"}`;\n')),(0,r.kt)("p",null,"You use this path pattern both when routing incoming requests:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function handleRequest(request, response) {\n  const args = profile.match(request.path);\n\n  if (args) return renderProfile(args, request, response);\n\n  // ...\n}\n")),(0,r.kt)("p",null,"And when building the links to profile pages:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function renderProfileLink(args) {\n  const { username } = args;\n\n  return `<a href="${profile.build(args)}">${username}</a>`;\n}\n')),(0,r.kt)("p",null,"This works fine until one day when a user signs up with the username ",(0,r.kt)("inlineCode",{parentName:"p"},"settings"),".\nNow your application is broken because everyone who tries to access your\napplication's settings at ",(0,r.kt)("inlineCode",{parentName:"p"},"/settings")," is getting a user profile instead. So you\ndecide it might be a better idea to give profile paths a small prefix.\nThankfully, this is very simple change. All you have to change is the profile\npath pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const profile = path`/profile/${"username"}`;\n')),(0,r.kt)("p",null,"Since you didn't change the parameters, there's no need to change your\napplication's routing code, or any of your profile links. Everything will update\nto use the new ",(0,r.kt)("inlineCode",{parentName:"p"},"/profile/")," prefix automatically! This kind of refactoring power\ncan be extremely useful in large applications with lots of links and routes."),(0,r.kt)("h3",{id:"building-with-multiple-parameters"},"Building with multiple parameters"),(0,r.kt)("p",null,"If your path pattern has multiple parameters, you'll need to supply arguments\nwith a property for each parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst pluginSettings = path`/plugin/${"plugin"}/settings/${"type"}`;\n\n// returns \'/plugin/snout-router/settings/routes\'\npluginSettings.build({ plugin: "snout-router", type: "routes" });\n\n// returns \'/plugin/dogma/settings/apps\'\npluginSettings.build({ plugin: "dogma", type: "apps" });\n')),(0,r.kt)("p",null,"As with single-parameter path patterns, additional arguments will have no affect\non the output path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'// returns \'/plugin/github/settings/credentials\'\npluginSettings.build({ extra: "snout", plugin: "github", type: "credentials" });\n')),(0,r.kt)("h3",{id:"building-with-no-parameters"},"Building with no parameters"),(0,r.kt)("p",null,"If your path pattern has no parameters, you can supply empty arguments (i.e. an\nempty object) to build a path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"import { path } from \"@snout/router-path\";\n\nconst dashboard = path`/dashboard`;\n\n// returns '/dashboard'\ndashboard.build({});\n")),(0,r.kt)("p",null,"As with single-parameter path patterns, additional arguments will have no affect\non the output path:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},"// returns '/dashboard'\ndashboard.build({ bonus: \"pachyderm\" });\n")),(0,r.kt)("h3",{id:"build-argument-types"},"Build argument types"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),", the compiler will warn you if you're using the\nwrong arguments when building paths:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { some } from "@snout/router-path-extras";\n\nconst articles = path`/articles/${"category"}/tagged/${some("tags")}`;\n\n// TypeScript "knows" that build arguments need to contain:\n//   - category: A string\n//   - tags:     An array of strings with at least one member\n\narticles.build({ category: "pachyderms", tags: ["huge", "snouts"] }); // no error\narticles.build({ category: "pachyderms", tags: ["snouts"] }); // no error\n\narticles.build({ category: "pachyderms", tags: [] }); // type error - not enough tags\narticles.build({ category: "pachyderms" }); // type error - missing tags\narticles.build({ tags: ["snouts"] }); // type error - missing category\narticles.build({}); // type error - missing both\n')),(0,r.kt)("admonition",{title:"Try me!",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzAQxgCwL5wGZQiOAcgAEBnAOwgFcYB6PGgUygFoV1CAoUSWRU-Iyy58RMpRr1qMZm1RoWjAB4woyUl04BjCOVLxksYFoA2jUnAC8cdmgAGtQzGNnStACQJCW1IwDm0ACehBi0MMh+fowAJh4IAiCMABSE4X4aAJQYdpyctLRwACqBYIwAylpQwGDwAEQA1pQA7qS1cOiocABGVMAm0XCGflSJ5DAW5Iwx7RBwOmPIwOQAXHkFcHAsc74BUIHLcACCcPpV5H5rG5vtEaQHV0fkg1BqgXAQ2CeqS+lwTcDoQbwMzqeC6RhwRIgLrMXJOFzmAB0PT60SSCB8Ml2+yIKC0aEC0WYIA0ABobukDgBtQhoKhRQjkwgUaQaAC6GAycHycEocGYeCgnHhpiRKP66Mx-iCB0IeIJRKgJMZFLucBpLJo7M5D11PL5AugcKMotIyN6EoxOxluOQ+MJxLJqupHK5PJgJQhhqg10o8EYEj8aFVwpNrnNqMl1r2svlDqVGh1ur1BQ9pX5L2g1xAwFIpB+IZF4fFaIQaTVGok40IruTdYe7s9GcF2dz+fO2yxQVDzlNEctSfrQ+HDdTTe9rbzBa6EHQQA"},"Try this example in the TypeScript Playground"))),(0,r.kt)("h3",{id:"building-with-simple-parameters"},"Building with simple parameters"),(0,r.kt)("p",null,"The simple parameters that come out of the box with ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," accept\nstring arguments. If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),", this will be enforced at compile\ntime. If you're using vanilla JavaScript, you'll need to be careful and remember\nto do string conversion yourself:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst group = path`/group/${"id"}`;\n\ngroup.build({ id: "111" }); // strings are fine\ngroup.build({ id: String(111) }); // other types should be converted\n\ngroup.build({ id: 111 }); // don\'t do this!\n')),(0,r.kt)("p",null,"If you supply a simple parameter with an ",(0,r.kt)("em",{parentName:"p"},"empty")," string argument when building a\npath, an exception will be thrown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'group.build({ id: "" }); // throws \'Empty parameter "id"\'\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"You might notice that passing non-string arguments to simple parameters actually\nworks just fine in some cases. But there's no guarantee this will continue to\nwork in future versions of ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path"),"."),(0,r.kt)("p",{parentName:"admonition"},"You might also wonder why ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," doesn't throw an error for\nnon-string or missing arguments. Simple parameters are optimized for\n",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," usage, and purposefully don't do any run-time checks that would be\nredundant in a ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," environment.")),(0,r.kt)("h3",{id:"building-with-custom-parameters"},"Building with custom parameters"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameters")," in your patterns, the type and content of\nthe arguments you'll need to supply when building paths is largely up to the\nimplementation of each parameter. Some ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameter")," implementations just\naccept argument types other than strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { int } from "@snout/router-path-extras";\n\nconst job = path`/job/${int("num")}`;\n\n// returns \'/job/111\' - note that num is a number, not a string\njob.build({ num: 111 });\n')),(0,r.kt)("p",null,"But ",(0,r.kt)("a",{parentName:"p",href:"/router-path/guides/custom-parameters"},"custom parameter")," implementations also have the power to accept just about\nany type of argument, or even allow arguments to be omitted entirely. So check\ntheir individual documentation for more specific information on how they behave\nwhen building paths:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\nimport { optional } from "@snout/router-path-extras";\n\nconst pachyderms = path`/pachyderms${optional`/with/${"feature"}`}`;\n\npachyderms.build({}); // returns \'/pachyderms\'\npachyderms.build({ feature: "snouts" }); // returns \'/pachyderms/with/snouts\'\n')),(0,r.kt)("h3",{id:"building-url-paths"},"Building URL paths"),(0,r.kt)("p",null,"If you're building URL paths, be aware that ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," does not\nautomatically encode characters for you. Depending on the strategy you're using\nfor building your URLs, you may need to handle this yourself. Thankfully, the\nstandard ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/API/URL"},"URL")," implementation available in most JavaScript environments handles\nthe encoding for you:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst article = path`/article/${"name"}`;\n\nconst url = new URL("https://snout.dev/");\nurl.pathname = article.build({ name: "10 Biggest Snouts" });\n\n// returns \'https://snout.dev/article/10%20Biggest%20Snouts\'\nurl.toString();\n')))}m.isMDXComponent=!0}}]);