"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[462],{3905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>g});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),u=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},l=function(e){var t=u(e.components);return n.createElement(i.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=u(a),h=r,g=m["".concat(i,".").concat(h)]||m[h]||c[h]||s;return a?n.createElement(g,o(o({ref:t},l),{},{components:a})):n.createElement(g,o({ref:t},l))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=h;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[m]="string"==typeof e?e:r,o[1]=p;for(var u=2;u<s;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(4334);const s={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,o),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>N});var n=a(7462),r=a(7294),s=a(4334),o=a(2466),p=a(6550),i=a(1980),u=a(7392),l=a(12);function m(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function c(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??m(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function g(e){let{queryString:t=!1,groupId:a}=e;const n=(0,p.k6)(),s=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,i._X)(s),(0,r.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(n.location.search);t.set(s,e),n.replace({...n.location,search:t.toString()})}),[s,n])]}function d(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,s=c(e),[o,p]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[i,u]=g({queryString:a,groupId:n}),[m,d]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,s]=(0,l.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&s.set(e)}),[a,s])]}({groupId:n}),f=(()=>{const e=i??m;return h({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{f&&p(f)}),[f]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);p(e),u(e),d(e)}),[u,d,s]),tabValues:s}}var f=a(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function k(e){let{className:t,block:a,selectedValue:p,selectValue:i,tabValues:u}=e;const l=[],{blockElementScrollPositionUntilNextRender:m}=(0,o.o5)(),c=e=>{const t=e.currentTarget,a=l.indexOf(t),n=u[a].value;n!==p&&(m(t),i(n))},h=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;t=l[a]??l[0];break}case"ArrowLeft":{const a=l.indexOf(e.currentTarget)-1;t=l[a]??l[l.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:p===t?0:-1,"aria-selected":p===t,key:t,ref:e=>l.push(e),onKeyDown:h,onClick:c},o,{className:(0,s.Z)("tabs__item",y.tabItem,o?.className,{"tabs__item--active":p===t})}),a??t)})))}function b(e){let{lazy:t,children:a,selectedValue:n}=e;const s=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function v(e){const t=d(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",y.tabList)},r.createElement(k,(0,n.Z)({},e,t)),r.createElement(b,(0,n.Z)({},e,t)))}function N(e){const t=(0,f.Z)();return r.createElement(v,(0,n.Z)({key:String(t)},e))}},7007:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>p,metadata:()=>u,toc:()=>m});var n=a(7462),r=(a(7294),a(3905)),s=a(5162),o=a(4866);const p={sidebar_position:1},i="Custom parameters",u={unversionedId:"guides/custom-parameters",id:"guides/custom-parameters",title:"Custom parameters",description:"Out of the box, Snout Router Path only supports very basic string-based",source:"@site/../docs/guides/custom-parameters.mdx",sourceDirName:"guides",slug:"/guides/custom-parameters",permalink:"/router-path/guides/custom-parameters",draft:!1,editUrl:"https://github.com/snout-router/router-path/edit/main/website/../docs/guides/custom-parameters.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"Path patterns",permalink:"/router-path/guides/path-patterns"},next:{title:"API reference",permalink:"/router-path/api"}},l={},m=[{value:"Matching and parsing",id:"matching-and-parsing",level:2},{value:"Parameter affixes",id:"parameter-affixes",level:3},{value:"Path separators",id:"path-separators",level:3},{value:"Path segments",id:"path-segments",level:3},{value:"Formatting",id:"formatting",level:2},{value:"Type safety",id:"type-safety",level:2},{value:"Type-safe parameter names",id:"type-safe-parameter-names",level:3}],c={toc:m},h="wrapper";function g(e){let{components:t,...a}=e;return(0,r.kt)(h,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"custom-parameters"},"Custom parameters"),(0,r.kt)("p",null,"Out of the box, ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path")," only supports very basic string-based\nparameters that consume a single path segment. If you need more complicated\nbehavior, you can either bring in an additional dependency like\n",(0,r.kt)("a",{parentName:"p",href:"https://snout.dev/router-path-extras"},(0,r.kt)("inlineCode",{parentName:"a"},"@snout/router-path-extras")),", or you can implement your own custom parameters."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"If you've implemented custom parameters for ",(0,r.kt)("strong",{parentName:"p"},"Snout Router Path"),", we'd love to\nhear about it! At the time of writing, it's early days for this project. We will\nmost likely put together a list of custom parameter packages if/when they start\nappearing.")),(0,r.kt)("h2",{id:"matching-and-parsing"},"Matching and parsing"),(0,r.kt)("p",null,"When matching a path against a pattern, the individual parameters contribute to\ndeciding whether the overall path matches the pattern or not. The ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp")),"\nproperty of a route parameter is a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/docs/Web/JavaScript/Guide/Regular_Expressions"},"regular expression")," that is used to match a\n",(0,r.kt)("em",{parentName:"p"},"portion")," of the path. This expression ",(0,r.kt)("strong",{parentName:"p"},"must")," have exactly one\n",(0,r.kt)("a",{parentName:"p",href:"https://javascript.info/regexp-groups"},"capturing group"),"."),(0,r.kt)("p",null,"When a path matches a pattern, the content captured by ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp")),"'s\n",(0,r.kt)("a",{parentName:"p",href:"https://javascript.info/regexp-groups"},"capturing group")," gets passed to ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-parse"},(0,r.kt)("inlineCode",{parentName:"a"},"parse"))," for further parsing. ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-parse"},(0,r.kt)("inlineCode",{parentName:"a"},"parse"))," itself\nis not restricted to returning strings; it's possible to return any type of\nvalue you want. JavaScript will obviously not complain about the return type.\n",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," will expect you to honor the type variables used in the specified\n",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param"},(0,r.kt)("inlineCode",{parentName:"a"},"Param"))," type."),(0,r.kt)("p",null,"These features work together to make it possible to implement just about any\ntype of parameter you can imagine. As an example, consider parameters based on\nintegers instead of strings:"),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Param, path } from "@snout/router-path";\n\nfunction int<Name extends string>(name: Name): Param<Name, number> {\n  return {\n    name,\n    exp: /(0|[1-9]\\d*)/, // `exp` allows integer strings only, no leading zeroes\n    format: (arg) => `${Math.floor(arg)}`,\n    parse: (match) => parseInt(match, 10),\n  };\n}\n\nconst user = path`/user/${int("id")}`;\n\nuser.test("/user/111"); // returns true\nuser.test("/user/011"); // returns false\nuser.test("/user/abc"); // returns false\n'))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { path } from "@snout/router-path";\n\nfunction int(name) {\n  return {\n    name,\n    exp: /(0|[1-9]\\d*)/,\n    format: (arg) => `${Math.floor(arg)}`,\n    parse: (match) => parseInt(match, 10),\n  };\n}\n\nconst user = path`/user/${int("id")}`;\n\nuser.test("/user/111"); // returns true\nuser.test("/user/011"); // returns false\nuser.test("/user/abc"); // returns false\n')))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Before implementing your own custom parameters, be sure to check out the\n",(0,r.kt)("a",{parentName:"p",href:"https://snout.dev/router-path-extras"},(0,r.kt)("inlineCode",{parentName:"a"},"@snout/router-path-extras"))," package, which has some commonly desired parameter\ntype implementations - including the integer parameters from the example above.")),(0,r.kt)("h3",{id:"parameter-affixes"},"Parameter affixes"),(0,r.kt)("p",null,"On a successful path match, only the ",(0,r.kt)("a",{parentName:"p",href:"https://javascript.info/regexp-groups"},"capturing group")," content from ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp")),"\nactually gets passed to ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-parse"},(0,r.kt)("inlineCode",{parentName:"a"},"parse")),". This means it's possible to consume prefixes\nand suffixes with ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp")),", without having to deal with them in ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-parse"},(0,r.kt)("inlineCode",{parentName:"a"},"parse"))," as\nwell:"),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Param, path } from "@snout/router-path";\n\nfunction lang(): Param<"lang"> {\n  return {\n    name: "lang",\n    exp: /lang-([a-z]{2}-[A-Z]{2})/, // `exp` allows strings like "lang-en-US"\n    format: (arg) => `lang-${arg}`, // the prefix must be re-added when formatting\n    parse: (match) => match, // no need to strip the prefix when parsing\n  };\n}\n\nconst documents = path`/documents/${lang()}`;\n\ndocuments.match("/documents/lang-en-US"); // returns { lang: "en-US" }\ndocuments.match("/documents/lang-ko-KR"); // returns { lang: "ko-KR" }\n'))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { path } from "@snout/router-path";\n\nfunction lang() {\n  return {\n    name: "lang",\n    exp: /lang-([a-z]{2}-[A-Z]{2})/,\n    format: (arg) => `lang-${arg}`,\n    parse: (match) => match, // no need to strip the prefix when parsing\n  };\n}\n\nconst documents = path`/documents/${lang()}`;\n\ndocuments.match("/documents/lang-en-US"); // returns { lang: "en-US" }\ndocuments.match("/documents/lang-ko-KR"); // returns { lang: "ko-KR" }\n')))),(0,r.kt)("p",null,"Note that you can also build affixes into path pattern segments, which is\nanother way to handle them. This is a simpler solution than implementing a\ncustom parameter in many cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { path } from "@snout/router-path";\n\nconst documents = path`/documents/lang-${"lang"}`;\n\ndocuments.match("/documents/lang-en-US"); // returns { lang: "en-US" }\ndocuments.match("/documents/lang-ko-KR"); // returns { lang: "ko-KR" }\n')),(0,r.kt)("h3",{id:"path-separators"},"Path separators"),(0,r.kt)("p",null,"Although it's common to use ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," as a separator for path segments, it's possible\nto use ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp"))," to implement paths that use other separators:"),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Param, path } from "@snout/router-path";\n\nfunction dotted<Name extends string>(name: Name): Param<Name> {\n  return {\n    name,\n    exp: /([^.]+)/, // `exp` consumes everything up until the next `.`\n    format: (arg) => arg,\n    parse: (match) => match,\n  };\n}\n\nconst roles = path`user.${dotted("username")}.roles`;\n\nroles.match("user.piglet.roles"); // returns { username: "piglet" }\nroles.match("user.snouty.roles"); // returns { username: "snouty" }\n'))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { path } from "@snout/router-path";\n\nfunction dotted(name) {\n  return {\n    name,\n    exp: /([^.]+)/,\n    format: (arg) => arg,\n    parse: (match) => match,\n  };\n}\n\nconst roles = path`user.${dotted("username")}.roles`;\n\nroles.match("user.piglet.roles"); // returns { username: "piglet" }\nroles.match("user.snouty.roles"); // returns { username: "snouty" }\n')))),(0,r.kt)("h3",{id:"path-segments"},"Path segments"),(0,r.kt)("p",null,"Parameters typically consume a single path segment, but this is actually\ndetermined by ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param#property-exp"},(0,r.kt)("inlineCode",{parentName:"a"},"exp")),", which can be made to consume multiple path segments:"),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Param, path } from "@snout/router-path";\n\nfunction anything<Name extends string>(name: Name): Param<Name> {\n  return {\n    name,\n    exp: /(.+)/,\n    format: (arg) => arg,\n    parse: (match) => match,\n  };\n}\n\nconst article = path`/article/${anything("etc")}`;\n\narticle.match("/article/10 Biggest Snouts"); // returns { etc: "10 Biggest Snouts" }\narticle.match("/article/sci-fi/space-pigs"); // returns { etc: "sci-fi/space-pigs" }\n'))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { path } from "@snout/router-path";\n\nfunction anything(name) {\n  return {\n    name,\n    exp: /(.+)/,\n    format: (arg) => arg,\n    parse: (match) => match,\n  };\n}\n\nconst article = path`/article/${anything("etc")}`;\n\narticle.match("/article/10 Biggest Snouts"); // returns { etc: "10 Biggest Snouts" }\narticle.match("/article/sci-fi/space-pigs"); // returns { etc: "sci-fi/space-pigs" }\n')))),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Implementing parameters that consume multiple path segments can get complicated\nvery quickly. If you really need this kind of behavior, perhaps try using query\nstring parameters instead of route parameters, or check out the\n",(0,r.kt)("a",{parentName:"p",href:"https://snout.dev/router-path-extras"},(0,r.kt)("inlineCode",{parentName:"a"},"@snout/router-path-extras")),' package, which has some commonly desired parameter\ntype implementations - including "repeating" parameter types such as ',(0,r.kt)("inlineCode",{parentName:"p"},"any")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"some"),".")),(0,r.kt)("h2",{id:"formatting"},"Formatting"),(0,r.kt)("p",null,"When building a path from a pattern, the individual parameters contribute to\nbuilding the overall path by formatting the arguments they are passed. No matter\nwhat type of arguments a parameter accepts, it must always be able to format an\nargument into a string that makes up a ",(0,r.kt)("em",{parentName:"p"},"portion")," of a path."),(0,r.kt)("p",null,"For example, the integer-based parameters used as an example in the\n",(0,r.kt)("a",{parentName:"p",href:"#matching-and-parsing"},"Matching and Parsing")," section are also responsible for formatting the numbers\nthey are passed when building a path that uses them. They do so by implementing\nthe ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param##method-format"},(0,r.kt)("inlineCode",{parentName:"a"},"format"))," method:"),(0,r.kt)(o.Z,{groupId:"language",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Param, path } from "@snout/router-path";\n\nfunction int<Name extends string>(name: Name): Param<Name, number> {\n  return {\n    name,\n    exp: /(0|[1-9]\\d*)/,\n    format: (arg) => `${Math.floor(arg)}`, // `format` formats a number as an integer string\n    parse: (match) => parseInt(match, 10),\n  };\n}\n\nconst user = path`/user/${int("id")}`;\n\nuser.build({ id: 111 }); // returns "/user/111"\nuser.build({ id: 222 }); // returns "/user/222"\n'))),(0,r.kt)(s.Z,{value:"js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { path } from "@snout/router-path";\n\nfunction int(name) {\n  return {\n    name,\n    exp: /(0|[1-9]\\d*)/,\n    format: (arg) => `${Math.floor(arg)}`,\n    parse: (match) => parseInt(match, 10),\n  };\n}\n\nconst user = path`/user/${int("id")}`;\n\nuser.build({ id: 111 }); // returns "/user/111"\nuser.build({ id: 222 }); // returns "/user/222"\n')))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},'When implementing custom parameters, it\'s important that the two "halves" of the\nimplementation match up. In other words, a parameter should always be able to\nparse its own formatting.')),(0,r.kt)("h2",{id:"type-safety"},"Type safety"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),", you can take advantage of type checking in your\ncustom parameters by implementing the ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param"},(0,r.kt)("inlineCode",{parentName:"a"},"Param"))," interface correctly. For\ninstance, using the integer parameters from previous examples, ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," can\nwarn us when we try to use a parameter that does not exist, or if we try to use\nan incorrect variable type with a parameter that does exist:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'const user = path`/user/${int("id")}`;\n\n// TypeScript "knows" that a successful match will contain a number for "id":\n\nconst match = user.match("/user/111");\n\nif (match) {\n  console.log(match.id.toExponential()); // no error\n  console.log(match.id.toUpperCase()); // type error\n  console.log(match.nonexistent); // type error\n}\n\n// TypeScript "knows" that we need a number for "id" when building the path:\n\nuser.build({ id: 111 }); // no error\nuser.build({ id: "111" }); // type error\nuser.build({}); // type error\n')),(0,r.kt)("admonition",{title:"Try me!",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAbzgBQIZVSANHMqYAWcAvnAGZQQhwBEAAgM4B2EArjAPSXsCmUAtHkI0A3ACgxZVkwDGMYBCZxgTGAB4Acph5weADxg8mAEwZwGMKCoDmAPgAUTbQC44WkDwCUrtBhCbtHCZWEAAjPltEMTg4KB4YViglBGiYuCcPLFSY-TBXDnsABgAfAG0ARn4ATgBdAB1jACpPDiy08mgQfFd7dGtPOABeSIADABIEAFl8AgA6MgAbCGheqH7iEZwODjgRsk78EY6oLpgzVHSQ8Kg4VHOlFUNrPnNLG2zcdAYeHtOZAgGw0+UG+AElVPY-gQcOVCp42iRxMQJDJFBY4KxvjdBp9CCMOJi+BwJo97DRgMYaJ4NuIxNs4AAVACeYB4AGUZFYwPAaABrFgAdwYNDghHwt3MrBkMh4DAYUgWcChcAFwAWitRqlQKglwTCL32N3JlOcKLR8GVOMJUFmULJBKxHHKzqptOAZDgkPw-wGKRimoYEAWPFmS2sXpg-1mFNmMAgAFE9JAmEZ5KgFvZPJ4RHB6SxdFBKFBUgGgyGwxGozG4wBVMCsqAAYTuPEz2dzOxgLJ0fCLJbRZdDEHDUNmLBTemAFlT7fpXdZBb7yLpO2ZrI5XJ5-IgQpFYvgAp0KZ4xl1VwN0FoFJFAoIRjgoVYauMNlFd9xBFNYmts0fz-sSAUq4zrlCQs47PmvbQN+WK-k+CzGAByjGK4NAgSKxDgaK3aLtBP5-ghAGYTmc44VBUBAA"},"Try this example in the TypeScript Playground"))),(0,r.kt)("h3",{id:"type-safe-parameter-names"},"Type-safe parameter names"),(0,r.kt)("p",null,"You may have noticed by reading the examples in this guide, that ",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param"},(0,r.kt)("inlineCode",{parentName:"a"},"Param"))," has a\n",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param##type-variable-name"},(0,r.kt)("inlineCode",{parentName:"a"},"Name"))," type variable for the parameter name. This ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types"},"literal type"),"\ncontains the name of the parameter, but in a way that ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript"),"'s type system\nunderstands. This is a key part of how ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," can know about the\n",(0,r.kt)("em",{parentName:"p"},"existence")," of route parameters."),(0,r.kt)("p",null,"The best way to ensure that custom parameters have the correct\n",(0,r.kt)("a",{parentName:"p",href:"/router-path/api/type/Param##type-variable-name"},(0,r.kt)("inlineCode",{parentName:"a"},"Name"))," type associated with them, is to use a ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/generics.html"},"generic")," function to\ncreate them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { Param, path } from "@snout/router-path";\n\nfunction customParam<Name extends string>(name: Name): Param<Name> {\n  return {\n    name,\n    exp: /([^/]+)/,\n    format: (arg) => arg,\n    parse: (match) => match,\n  };\n}\n\nconst category = customParam("category");\nconst id = customParam("id");\n\nconst article = path`/article/${category}/${id}`;\n')),(0,r.kt)("p",null,"It's also possible to directly create one-off parameters with ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types"},"literal type"),"\nnames in various ways using ",(0,r.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/"},"TypeScript")," syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"no-transpile","no-transpile":!0},'import { Param, path } from "@snout/router-path";\n\n// explicit\nconst category: Param<"category"> = {\n  name: "category",\n  exp: /([^/]+)/,\n  format: (arg) => arg,\n  parse: (match) => match,\n};\n\n// implicit\nconst id = {\n  name: "id" as "id",\n  exp: /([^/]+)/,\n  format: (arg: string) => arg,\n  parse: (match: string) => match,\n};\n\nconst article = path`/article/${category}/${id}`;\n')))}g.isMDXComponent=!0}}]);